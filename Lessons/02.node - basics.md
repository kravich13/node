# Node Basics

- [Node Basics](#node-basics)
	- [Modules](#modules)
		- [Module Wrapper Function](#module-wrapper-function)
	- [`global`](#global)
	- [App params](#app-params)
	- [Events](#events)
	- [Buffer](#buffer)
		- [Creating Buffers](#creating-buffers)
		- [Methods](#methods)
			- [`buf.write(string[, offset[, length]][, encoding])`](#bufwritestring-offset-length-encoding)
			- [`buf.writeInt32BE(value[, offset])`](#bufwriteint32bevalue-offset)


***

Basic server (`app.js`):

```js
const http = require('http')
const PORT = process.env.PORT || 5000

const server = http.createServer((req, res) => {
	res.end('end')
})

server.listen(PORT, () => {
	console.log('Server is running on port ', PORT) 
})
```

Run it in the project folder: 

```bash
# assuming you've already installed `nodemon`
nodemon app
```

***



## Modules

Modules are separate script files that you export and import. 

To **export**: `module.exports = obj`

To **import**: `const obj = require('./obj')`

```javascript
// person.js
class Person {
	constructor(name, age){
		this.name = name
		this.age = age
	}

	greet(){
		console.log(`My name is ${this.name} and I'm ${this.age}`)
	}
}

module.exports = Person
```

```javascript
// index.js
const Person = require('./person')
const person1 = new Person('Alex', 30)
person1.greet()
```

***

```js
const greeting1 = require("./greeting.js")
const greeting2 = require("./greeting.js")

console.log(greeting1 === greeting2)	// true
```

***

We may refer not only to the module files but also to the module folders if they have the `index.js` file that represents them:

```js
/* Project structure:
welcome
	index.js
	morning.js
	evening.js
app.js
*/

// morning.js
module.exports = 'Good morning'

// evening.js
module.exports = `Good evening`

// index.js
module.exports = {
	getMorningMessage(){
		console.log(require('./morning'))
	},
	getEveningMessage(){
		console.log(require('./evening'))
	}
}

// app.js
const welcome = require(`./welcome`)	
// there's not `welcome` module but this still works because the folder `module` has `index.js` inside
console.log(welcome.getEveningMessage())	// Good evening
```

***


### Module Wrapper Function

The content of the modules is actually wrapped with a special function:

```javascript
(function (exports, require, module, __filename, __dirname){
	// your module
})
```

We can check it using  `console.log`:

```javascript
// person.js
console.log(__filename, '\n', __dirname)

// Output:
// /home/max/Dev/a-level/Repeating/Node/Crash Course/01-intro/person.js
// /home/max/Dev/a-level/Repeating/Node/Crash Course/01-intro
```

***


## `global`

Special object storing all global variables and functions, accessible from any module. Similar to `window` in browsers.

```js
// script.js
global.date = new Date()

// app.js
console.log(global.date)	// our date even without import
```

***


## App params

When we launch our app from the command line, we can pass **parameters** to it: They are then accessible from **`process.argv`**. 

- `process.argv[0]` - path to **`node`** itself
- `process.argv[1]` - path to the **app**
- `process.argv[2], [3], ...` - parameters for the app

```bash
# call the app this way
nodemon app arg1 arg2
```

```js
console.log(process.argv)
/* [
  '/usr/bin/node',
  '/home/max/Dev/Study/NODE/Projects/Test/app.js',
  'arg1',
  'arg2'
] */
```

***



## Events

See `events.md` in `module-reference`.

***



## Buffer

Represens a fixed-length sequence of bytes. (e.g. coming from **streams**). It is a subclass of JavaScript's `Uint8Array`. 

Max size is ~2 GB.

Buffers act somewhat like arrays of integers, but **aren't resizable** and have a whole bunch of methods specifically for binary data. 

`1 byte == 8 bits == values[0 - 255] == values[00 - FF]`

Thus, each byte is represented by a **hexadecimal** number with 2 digits. 

***


### Creating Buffers

There are a few ways to create new buffers:

1. `Buffer.alloc(size[, fill[, encoding]])` - allocate memory in bytes and fill with data (defaults are **zeros**). 

```js
// allocate 8 bytes of memory
let buffer = Buffer.alloc(8)
console.log(buffer)
// <Buffer 00 00 00 00 00 00 00 00>

// allocate 4 bytes and fill with 'a'-s
buffer = Buffer.alloc(4, 'a')
console.log(buffer)
// <Buffer 61 61 61 61>

// also set encoding - the same as calling buf.fill(fill, encoding)
buffer = Buffer.alloc(4, 'a', )
console.log(buffer)
```

```js
// from an array
buffer = Buffer.from([ 255, 15, , 9])
console.log(buffer)
// <Buffer ff 0f 00 09>


// from a string
buffer = Buffer.from("I'm a string!", "utf-8")
console.log(buffer)
// <Buffer 49 27 6d 20 61 20 73 74 72 69 6e 67 21>
console.log(buffer.toString())
// I'm a string!
```

***


### Methods

#### `buf.write(string[, offset[, length]][, encoding])`

- `string`: String to write to buf.
- `offset`: Number of bytes to skip before starting to write string. Default: 0.
- `length`: Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`).
- `encoding`: The character encoding of string. Default: `'utf8'`.
- **`Returns`** the number of bytes written.

```js
const buf = Buffer.alloc(8)
// will start writing from [3] position and will only write 3 bytes from the given string
buf.write('abcdf', 2, 3)
console.log(buf)
// <Buffer 00 00 61 62 63 00 00 00>
```

The **returned value** helps us to write down data further:

```js
const buf = Buffer.alloc(16)
let len = buf.write('Hello')	// 5 bytes added
console.log(len)	// 5
len += buf.write(' world', len)	// 6 bytes added
console.log(len)	// 11
len += buf.write('!', len)		// 1 byte added
console.log(len)	// 12

console.log(buf.toString())	// Hello, world!
```

***


#### `buf.writeInt32BE(value[, offset])`

A big range of methods of this type are available, they are all the same, just use different **words** to write down.

The difference between **BE** (big-endian) and **LE** (little-indian) is in representation of digits: decreasing or increasing memory significance (123 or 321). **BE** is used most often.

```js
const buf = Buffer.alloc(4)
// write 2-byte word of '5' with the offset of 1 byte (i.e. starting with [1])
buf.writeInt16BE('5', 1)	

console.log(buf)	// <Buffer 00 00 05 00>
// 16-bit == 2-byte word looks like this: [00 05]. And with offset 1 it moves right by one byte more.
```